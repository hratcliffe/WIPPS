//
//  main.h
//  
//
//  Created by Heather Ratcliffe on 18/09/2015.
//
//

#ifndef ____main__
#define ____main__

//#include <stdio.h>


#endif /* defined(____main__) */

//The following is Doxygen mainpage docs
/*! \mainpage notitle
 
 * \section Introduction
 * This program post-processes EPOCH PIC code output files to explore Whistler wave-particle interactions. It can create wave spectra, and calculate theory based growth rates and particle diffusion coefficients.
 *
 * The modules tab shows the various parts of the code. Broadly, we have classes to store data, access data from files, represent physical entities such as plasma, and non-thermal electrons, and to perform required calculations.
 *
 * \subsection setup Code Setup
 * Setup and use of the code is via a combination of config files and command line arguments. These specify the domain, working directory etc. For each program, help on the command line arguments is available with \verbatim name -h \endverbatim
 * Larger pieces of configuration are read from files. We use the deck.status file generated by EPOCH for user defined constants, a plasma.conf file for background plasma configuration and a non-thermal.conf file for non-thermal electron distributions (required for growth rate calculations). Examples of all the conf files are in the ./files subdirectory.
 *
 * Some of the programs can use multiple cores, by parallelising over space.
 *
 * \subsection Data Arrays
 * Data arrays are a specialised class containing data, axes and information. Data should only be directly accessed when copying as the internal layout may change. Get/set_element methods are provided for accessing specific parts.
 * \subsection FileIO SDF IO
 * SDF file reading uses the SDF C libraries and extracts the selected field and axes from files sequentially, taking a suitable space subarray if necessary. It fills a data_array instance with this, which can then be worked with.
   Any version of the SDF libraries should be compatible since about version 4.3.
 * \subsection FFT Fourier Transforms and Special Functions
 * FFTs are handled by the FFTW routines in suitable precision (float or double). Special functions are provided by Boost.
 * \subsection contr Spectrum and D generation
 * The main calculations involving extracting a spectrum from the data read, and turning this into a diffusion coefficient, according to equations in Albert 2005 and/or Lyons 1972. Control of this process, matching spectra and coefficients and providing plasma parameters, is managed by the controller class.
 *\section prereqs Prerequisites
 * As well as the code, an install of boost is needed (exists on OSX and most Linux systems) as well as the correct version of FFTW libraries (float for float data, double for double). A copy of the SDF file libraries is needed from any version of EPOCH after about 4.6.3. To generate the docs Doxygen and pdftex are used.
 * \section docs This Documentation
 * These docs describe all classes and methods under the classes section. Helper functions, constants etc are grouped under modules.
 * 
 * Assumptions and caveats within the code are collected under \ref caveats. 
 * \section build Building or Editing the Code
 * An install script is provided to build SDF, install fftw etc. For details run install --help
 * Build using make. If input data is type double, use \verbatim make TYPE=double \endverbatim to build with correct FFT etc libraries.
 *Any changes to code include files or addition of files will change dependencies. In this case run \verbatim make echo_deps \endverbatim before a clean build
 * test, profile and debug options are also available. Use \verbatim make MODE=test \endverbatim etc to compile with correct flags, and see next sections for details
 *
 *\section test Integrated Testing
 * All (hopefully) significant (copout!) parts of the code should be covered by inbuilt tests. These are defined in tests.cpp and cover a mixture of unit testing, science testing and library integration tests. To run the tests, clean build with \verbatim make MODE=test \endverbatim
* and run. Errors and outcomes are written to stderr, information to stdout. Thus \verbatim ./main > /dev/null \endverbatim will show only the former, etc. 
* Some tests are rather heavy so are only run if flags are set. See \ref tests in the Test Docs for these. 
* By default, all compiles are at optimisation O3. To compile with O0 for testing or debugging, pass NO_OPT = 1 to the make command.

*To add tests, see class \ref tests. Consider adding tests for any significant additions or changes, and running the existing ones ditto. To include tests in this documentation, run
 \verbatim make MODE=test
make docs
 \endverbatim Similarly, to omit them, make without test mode
 *\section idl IDL routines
 *Some IDL helpers are provided for reading the output files, reading the deck.status file etc. To enable those which depend on SDF library IO, use the .idlstartup file in the files subdirectory, like, for example, \code IDL> pref_set, 'IDL_STARTUP', '/path/to/.idlstartup',/commit \endcode
 *
 *\section utils Utilities
 *As well as the main program, some utility programs are defined. These are built using make utils. For example, generate_ffts processes input data and outputs trimmed FFTs, or growth calculates theoretical growth rates of whistlers. These are described in the Utility subsection of the Modules tab

\section cpp Minimally wrong description of C++ as used here
*\subsection types Types and typedefs
*There's two ways to do a character string, old C-style array or characters, or a std::string (see below for meaning of std::). Some older functions expect the former, so the .c_str() conversion is used. I use C-strings for some things to match the libraries being used.
*The special type size_t is defined as an unsigned integer type large enough to count "anything". Unsigned so cannot be negative, but is used for counts, sizes etc.
* I have also added a typedef for the type in the data files and that to do the calculations in, my_type and calc_type respectively, defined in support.h. I decided to do all calculations as double, but as my data are float I use float versions of the FFTW libraries. 
*\subsection class Classes
*For this code, classes are basically structs containing data, with special methods (member functions). These always know the contents of the class and can access bits that might be hidden from the outside (private or protected).
* One class can extend another, as data_array does to my_array. The former holds just a chunk of data, the latter adds axes and additional functions.
*Once you have a class instance, i.e. a variable containing a thing of that class, you can call methods on it using the '.'
*Constructors are functions used to set up a new instance. For instance, if I want to make a 10x10 array, we set the parameters recording the dimension to define a 2-d array with sizes 10 and 10, and we grab some memory to store 10x10=100 data values etc. These special functions look like class_name(parameter list). We also have a destructor, which clean up when the variable is destroyed, and some special things which let us make copies, set one thing equal another and so on. These can be safely ignored.
*Quick example:
 data_array dat = data_array(10, 10); //Make a new 10x10 array
 dat.set_element(5, 5, 2.0); //Set element 5, 5 to 2.0
 my_type element = dat.get_element(5, 5); //element = 2.0
*
*\subsection pointer Pointers * and ->
*Some classes get rather large, for instance if they hold a lot of data internally. In this case, you might want to pass them about not by value (copying everything) but just by getting a pointer to where they are. Pointer variables are defined like
class * my_pointer with an asterix. This variable holds only the address. Conversions between pointer and instance are:
class * my_pointer = new class();
class my_instance = class();
my_instance = *(my_pointer); 'dereference' pointer to get value it points to
my_pointer = &(my_instance); take 'address of' instance to get pointer. 
The special operator '->' is used to apply a method to a pointer:
my_instance.set_element(5, 5, 2.0);
my_pointer->set_element(5, 5, 2.0);
Some of the core code uses these, none of the stuff in use should.
*The special id 'this' inside a class method refers to the instance the method was called on and is a pointer, so uses this->
*& in a function means that you may pass an instance, but a copy will not be made, the function will just be given the address. For instance the function to read data into an array dat is my_reader.read_data(dat, time, space); But a copy of dat is not made.

*\subsection colon The double colons ::
* The :: appears either with something like std:: or boost::math:: or with a class name, and means that this refers to the function X in that library, class etc. So there might be a function abs() in the standard std library and in a math library and one must distinguish between them. Or both my_array and data_array have a function called is_good() and the definitions must state which they refer to.

\defgroup cls Main Classes
*@{
\brief Major classes
*
*The major classes we use, dealing with data, physics etc
@}

*/

